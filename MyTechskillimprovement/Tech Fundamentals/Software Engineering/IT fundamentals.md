What is software Engineering ?
- It is the application of Scientific principles to the design and Creation of software.

- The field Uses a systematic approach to collect and analyze business requirements in order to design, build and test software applications to satisfy those business requirements.

Or 

Software Engineering is the systematic approach to design and development of software.


Software Engineers	Software Developers
It is the application of scientific principles to the design and creation  of software. 	

The field uses a systematic approach to collect and analyze business requirements in order to design, build and test software applications to satisfy those business requirements.	The field uses a creative approach to solve problems.
SE's use their knowledge to build entire systems.	SD's Use their knowledge to write code to implement specific functionality  within a system.
Software Engineers are often employed on larger scale projects and they are focussed on the broad structure rather than solving  an immediate problem.	
Software Engineers are tasked with 	
Designing, building and maintaining software systems
Responsibilities include writing and testing code, and consulting with stakeholders such as clients, third party software vendors, security specialists, and other team members.	

SDLC identifies the steps needed to develop high-quality software. 


What is SDLC ?
----------------
- It is the systematic process to develop high -quality software in a predictable timeframe and budget.

- The goal of sdlc is to produce software that meets a client's business requirements.

- SDLC defines phases of the software development process that encompass their own process and deliverables.

- It is a cycle of planning, design and development that can be implemented as an iterative approach to software development.

Following a linear pattern through discrete stages for the software development to manage projects is called "waterfall model"

Advantages of Following SDLC :
-----------------------------------------
>> It gives a development teams a process to follow rather than using an ad hoc approach to improve efficiency and reduce risks.

>> There are discrete phases to SDLC . Each phase is well defined so that team members know what they should be working on and when .

>> Problem solving is incorporated early in the cycle so problems are addressed in a timely fashion and can be addressed in the design phase rather than during coding.

>> Each team member has a well-defined role which reduces conflicts and overlapping responsiblities.


>> The ability to be used iteratively allowing for changing requirements.


Phases of SDLC : 
------------------------

![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/bb5c4274-fae7-411e-9227-5e9fa0177f37)
![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/59ceeb84-367b-48b8-acad-9d923b4fd14f)
![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/f5da834b-0eab-45db-89ee-a9637940bf08)




Prototyping :
>> Small scale replica to clarify requirements.
>> Tests design ideas.

Can be developed at various stages of SDLC.

Software Requirement Specification :
>> Requirements are documented in the SRC
>> All stackholders must agree.


![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/31e7dab4-c44d-458e-823a-8dd456f1cfd5)
![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/204d65c3-3b02-4cb5-9988-fe7bf605e58f)



>> It is also called as Building/Implementation phase.



![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/3bdfa20d-5af4-4335-9613-a66cc558b752)
![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/52d50681-58bd-4a08-b90c-55f1fc2d90b9)
![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/b259304e-a134-4e27-9013-13c47dfd57bd)
![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/c0642ada-0908-4edf-9b19-107f19f85613)



Software requirements can be classified into four broad categories:
1. functional,
2. external and User Interface, or UI,
3. system features,
4. and non-functional.

>> Software design is the process of transforming the requirements into a structure that is
implementable using code.
>> The software design process translates the requirements into a language the developers
can use to write the code. It transforms the requirements into a software solution.

>> The design communicates business rules and application logic, application programming interface design, which is how apps talk to each other or communicate with the database, user interfaces, and database design.

Code quality refers to the characteristics of the code including attributes such as
1. maintainability,
2. readability,
3. testability,
4. and security.
5. Quality code must fulfill the intended requirements of the software without defects.
6. Additionally, it should be
7. clean and consistent,
8. easy to read and maintain,
9. well documented,and efficient.

>> Software testing is the process of verifying that the software matches established requirements and is free of bugs.
Its purpose is to identify errors, gaps, or missing requirements when compared with stated requirements.
Properly tested software ensures reliability, security, performance, and efficiency.

Software testing can often be automated or done manually.
Levels of testing include unit, integration, system, user acceptance.
Unit testing is often done by the developer and tests the smallest component of code that can be isolated from the rest of the system.
Once the components are integrated into the larger product, integration testing occurs.
Then, after the larger product is deemed completed, system testing can take place.
User acceptance testing, or UAT for short and sometimes called beta testing, is when the software is tested by the intended end user. Types of testing can broadly be divided
into three categories,
 functional, 
non-functional, and
 regression. Testing levels

When the newest version of the software is distributed, it is referred to as a “release.”
Generally there is alpha, beta, and GA ( General Availability )

Alpha release :
The alpha release is the first functioning version of the system released to a select group of stakeholders.
The alpha release likely contains errors and
may not contain the full feature set but does contain most of the desired functionality.
Design changes may still occur during this release stage.

Beta Release :
The beta release, also called a limited release, is given to the stakeholders outside of the developing organization.
One of the intents of the beta release is to try out the software under real conditions, test the functionality, and identify any outstanding bugs or errors.
The beta release should meet all the functional requirements.
After beta release changes are agreed upon, made, and tested, and a stable version is released.

General Availability :

The audience for the GA release is all users.

Software documentation should be provided to both non-technical end-users and technical users.
System documentation is geared towards the technical user. Technical users may be other engineers, developers, or architects. System documentation explains how the software operates or how to use it. It consists of README files, inline comments, architecture and design documents, verification information, and maintenance guides.

User documentation is provided to the non-technical end-users to assist them in the use of the product. Generally, user documentation is provided in the form of user guides, instructional videos and manuals, online help, and inline help.

Requirement gathering is a six-step process of defining a problem to be solved and documenting how to go about solving that problem.
 These steps include:
1. identifying stakeholders,
2. establishing goals and objectives,
3. eliciting requirements from the stakeholders,
4. documenting the requirements,
5. analyzing and confirming the requirements, and
6. prioritizing.

Generally, the stakeholders work for the organization that requests the development of the software product.
Key personnel from the organization may include
1. decision-makers,
2. end-users,
3. system administrators,
4. engineering,
5. marketing,
6. sales,
7. and customer support personnel.

Typically, there may be three documents that result from the requirements gathering process:
1. software requirements specification, or SRS,
2. user requirements specification, or URS,
3. and system requirements specification, or SysRS.

Software Development Methodologies : 

![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/12b9c6ed-90b4-48cd-801d-93212bc0eb7f)
![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/44e565ae-db3a-442d-900c-48a56fb776a9)






Waterfall is a sequential method of software development where the output of one phase is the input for the next phase of the cycle.
>> Development and work on the next phase start only after the completion of the previous phase.
>> All planning, such as defining requirements and architectural design, is done up front.
>> The customer usually does not see the product until it is in the testing phase.
For a major version release of the product, the same process is repeated

![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/a77aa09c-dc04-4c09-9ebf-87ba73001596)

The V-shape model is named as such because the phases form the shape of a V.
The phases going down the left side of the V are called “verification".
Then, going up the right side of the V, those phases are called, "validation."
The V-shape model is like waterfall in that it is also sequential.
Each phase in verification corresponds with a validation phase.
There are four stages that occur on each side of the V. Going down the V are planning, system
design, architecture design, and then module design.
The bottom of the V is the coding phase.
And going back up the V are four phases that correspond to the phases going down the V:
unit testing,
integration testing,
system testing, and
acceptance testing.

1. The tests are written during the verification phases on the left and executed during the validation stages on the right.

Agile Software Development :
>> It focuses on a collaborative software development process over multiple short cycles rather than a strictly top-down linear process.

Teams work in cycles, or sprints, which are usually one to four weeks long.
Unit testing happens in each sprint to minimize the risk of failure.

At the end of each sprint, a chunk of working code is released at a meeting called the “sprint demo” where stakeholders can see the new functionality and provide feedback.
After the sprint demo, the entire process is repeated for every sprint cycle.
After several sprint cycles, a minimum viable product, or MVP, is developed so stakeholders can provide feedback on the basic feature set.

The four core values of Agile development outlined in what is known as the "Agile manifesto" are:
1. individuals and interactions over processes and tools
2. working software over comprehensive documentation
3. customer collaboration over contract negotiation, and
4. responding to change over following a plan.

>> Agile is cyclical.

Three of the common approaches to software development include waterfall, V-shape model, and Agile
>> waterfall and V-shape are sequential whereas Agile is iterative
Both waterfall and V-shape models are easy to implement but neither accommodates changing requirements well and Agile allows for changing requirements but resource allocation can be challenging.


>> Version numbers indicate when the software was released, when it was updated, and if any minor changes or patches were made to the software.
>> Software versioning is how software developers keep track of new software, updates, and patches for programs and applications.

A version still in beta or testing could have a version number lower than 1, such as 0.9.
A program or application with many releases and updates will have a longer number, sometimes 4 different number sets within the version number .

What do these numbers mean?
Some version numbers follow the semantic numbering system and have 4 parts separated by a period, but not all numbering systems follow this 4-part example.
In semantic numbering ,
 the first number indicates major changes to the software, such as a new release.
The second number indicates that minor changes were made to the software.
The third number in the version number indicates patches or minor bug fixes.
Finally, the fourth number indicates a build number or a build date, and it can indicate less significant changes made.

![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/23d1ef8e-a627-4e37-96cf-cf839dcab7a7)


Software Testing :

>> Software Testing is the practice of integrating quality checks throughout the software development cycle.
The purpose of testing is to check whether the software matches expected requirements and ensure error-free software.

In order to test software, the team writes "test cases"


>> These test cases are written to verify the functionality of a software application and ensure requirements have been satisfied.


A test case contains:
steps,
inputs,
data, and
the expected corresponding outputs. Regardless of the test type or development method, test cases
should always be written after requirements are finalized.

Testing types can  be broadly classified into three categories :
1. Functional Testing
2. Non-Functional Testing
3. Regression Testing

Functional Testing :
>> It usually involves black box black box testing which is a method of testing without looking at the source code or internal structure.
>> Functional testing only concerned with inputs and corresponding outputs of the system under test, also called SUT. It is entirely based on testing functional requirements.
>> Functional testing can be carried out manually or using automated tools.
>> The goal is to test the functionality of the application making sure the application is usable and accessible.
Non-Functional Testing : 
>> Non-Functional Testing includes testing the application for attributes like Performance, security, scalability and availability.
>> Non-Functional Testing checks to see if the SUTs non-functional behavior is performing properly.
>> Non-Functional Testing should answer questions like the following.
	How does the application behave under stress ?
	What happened when many users login at the same time ?
	Are the instructions in documents and user manuals consistent with the applications behaviour ?
	Does the application behave simmilarly under different operating systems ?
	How does the application handle disaster recovery ?
	How secure is the application ?
	
Regression Testing :
	>> Regression Testing also called as maintenance testing, confirms that a recent change to the application, such as bug fix, does not adversly affect already existing functionality. 
	>> Regression Testing should occur when there has been a change in requirements or when defects have been fixed.
	>> In order to conduct regression testing, all or some of the test cases should be selected to test against application.
	>> Regression Test case selection and prioritization can be challenging and can depend on several factors.
	
	Common reasons for regression test case selection include cases that : 
		Have frequent defects, 
		Contains frequently used functionality,
		Contain features with recent changes,
		Or are complex test cases,
		Edge cases and randomly successful or failed test cases.
		
		
There are Four Levels of Testing :

1. Unit,
2. Integration,
3. System and 
4. Acceptance.

>> Each level occurs at a different time in SDLC. There are 4 different levels in order to reduce the amount of time spent on testing by preventing overlap.


Unit testing refers to tests that verify the functionality of a specific section of code, usually at the function level.
>> It is performed by the software developer or engineer during the development phase of the software development life cycle.
>> Unit testing aims to eliminate construction errors before code is integrated with other modules. 
>> Unit testing is intended to increase the quality of the resulting software as well as the efficiency of the overall development process.
>> It verifies small, independent chunks of code.

Integration Testing : It seeks to identify errors when two or more smaller, independent code modules are combined.
>> Integration testing uncovers deficiencies in communication with a new module in conjunction with other existing modules, databases or external hardware.
>> It verifies two or more small chunks of code combination.

System Testing : occurs after integration testing and is conducted on a complete, integrated system to evaluate the system's compilance with its specified requirements.
>> It validates the system as a fully completed software product.
>> System testing is both functional and non-functional.
>> System Testing is done in a staging environment, which should be simmilar to production environment.

Acceptance Testing : it is a formal testing with respect to user needs, requirements and business processes.
>> It determines whether a system satisfies the needs of the users, customers, and other stakeholders.
>> Acceptance testing is usually done by the customer or the stakeholders during the maintenance stage of the SDLC.


Software Documentation 

>> It is the information about the software that describes what the product is and how to use it. These can be written, video or graphical assets associated with a software products development and use.

>> Documentation is an essential aspect of software Engineering applicable across all the phases of SDLC.
>> Software documentation can be written for different types of audiences - such as end users, software developers, QA engineers, system administrators and other stakeholders.
>> Documentation can be divided into two categories, Product and process.

	Product  documentation relates to the product's functionality. Whereas process documentation describes how to complete a task.
	Process documentation should provide the requirements for the quality implementation of business process.
	
	Documentation Categories :
	
	1. Requirements 
	2. Design
	3. Technical
	4. Quality Assurance
	5. User documentation
	
	

1. Requirements :
>> Requirements documentation is written during the planning phase of SDLC  and it is intended for development team including the developers, architects, and QA personnel.
>> Requirements documentation describes the expected features and functionality of the software system.
>>  It includes the software requirements specifications, system requirement specifications, and user acceptance specifications.
 
2. Design
	>> It is written by software architects and the development team to explain how the software will be built to meet the requirements.
	>> It consists of both conceptual and technical design documents.
3. Technical
>> Technical Documentation includes comments written in the code to help other developers read the code to understand its behavior. 
>> It also may including working papers that explain how the code works and documents that record engineer's ideas and thoughts during project implementation.
4. Quality Assurance
>> It includes all documents that pertain to a testing teams strategy, progress, and metrics.
Types of test documentation include test plans, test data, test scenarios, test cases, test strategies, and tracebility metrics.
>> Traceability metrics map test cases to their requirements.
5. User documentation
>> It is intended for end-users and explain how to operate the software or help them to install or troubleshoot the system.
>> End-user documentation includes frequently asked questions, installation and help guides, tutorials, and user manuals.
>> Standard operating procedures, called SOPs, often accompany process documentation.
>> process documentation provides an overview of a process. But SOPs go through much greater detail.
>> the SOP is written documentation that explains step by step how to accomplish a common yet a complex task that is organization specific.

SOPs can be in the form of a flowchart, hierarchichal outline, or step by step instructions.

In Agile, there is a Scrum master. Rather than focusing on planning, the Scrum master is focused on ensuring team and individual success. Remember that the four core Agile values prioritize people and communication over process, and the Scrum master is responsible for facilitating that communication.
 
![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/74bc7d1b-1ae4-45d2-ad82-669b2297ac17)




Software Development 
>> The environment for building websites and cloud applications is divided into two primary areas.
Front-end and back-end
Frontend deals with everything that happens in the client side , everything that the user can see and interact with .
>> You can choose to specialize in frontend coding tools like html, css, javascript and related frameworks, libraries and tools.
Backend deals with the everything that happens in the server side , before the code and data are sent to the client.
>> Backend coding usually handles the logic and functionality that makes the website or app work  and the authentication process that keeps data secure.
>> backend developers also deals with the database administrators in the bigger projects.

A team is a group of people working together towards a common goal.
>> Good teamwork encourages creativity, shares knowledge and results in better quality code.
>> Squads are small teams used in agile development.

>> Pair programming is an extension of teamwork where two developers work side by side at one computer.
>> pair programming builds technical and soft skills, results in a better quality code  and solutions and increase overall efficiency.

>> Code libraries are usually used to solve a specific problem or add a specific feature set.
>> Frameworks provide a standard way to build and deploy applications.
>> Version control systems keep track of what changes were made when and by whom and resolve any conflicts between changes.
>> The framework determines which subroutines and methods will be called when. When working with a framework, there is a specific structure that you must follow.
>> To use an analogy, if you are a carpenter building a house, the framework is the frame that you add to – bricks on the outside, plasterboard on the inside, and so on.
The frame acts as a guide for how the house is constructed.


>> CI/CD refers to the practices of continuous integration and either continuous delivery or continuous deployment.
>> A build tool transforms your source code into the binaries needed for installation.
Build tools organize your source code, set compile flags and manage dependencies.
>> Packages are archive files that contain the app files, instructions for installation, and any metadata that you choose.
>> Package Managers take care of the tasks for finding, installing, maintaining or uninstalling software packages at the user's request.
EX : Debian and RPM in linux
	Choclatey in windows
	
	Javascript/node.js --> npm
	Java --> Gradle and Maven
	Ruby --> RubyGems
	Python --> pip and conda
	
>> A software Stack is a combination of technologies that include software and programming languages.
>> A software stack is different from technology stack.

Introduction to Programming :
-----------------------------------------------
Programming languages helps us tell computers what to do.
There are two types of programming languages. They are 1. Interpreted language and 2. compiled language

1. Interpreted language :
>> Programs written in interpreted or scripted language, like python and HTML run through a programming interpreter on your computer's operating system or in your web browser.
>> Interpreted languages are also called as scripting languages.
EX : Javascript, python, Html

2. Compiled programs are applications and programs, like your music app or your operating system, that you run on your computer or device.
>> The programs are packaged --or compiled-- into one executable file. They are usually larger programs.
>> It piles the code into one file that runs when you double-click on the app on your device.
EX : C and Java
Interpreted 	Compiled
These programs are available across multiple platforms or in the cloud.	These programs are available to users with the same operating system coded in the same language.
Easy to Learn and use	 Difficult to learn and Use
They're better for websites because they tackle smaller, repeated processes.	they’re better for larger tasks, like running the operating system on your computer.
	 
How do developers choose a programming language ?
Developers choose which programming language is best to use depending on :
>> What they have the most experience with and what  they trust, what is best for their users, and what is the most efficient to use 


We can categorize programming languages into 2 levels. They are 1. high-level and 2. low-level

>> A high level programming language is more sophisticated and uses the common english language to make its code more understandable to increase the speed of coding and debugging programs

EX: Query languages such as SQL, structured programming languages such as pascal and object oriented programming languages such as Python.

>> Low-level programming languages include assembly languages such as ARM, MIPS and X86.
>> A query is a request for information from database.
>> The database handles the query and searches its tables for the information requested and returns the results to the querying entity.
>> When querying a database, it is important that both the user application making the query and the database handling the query are speaking the same language.
>> In programming terms, writing a query means using predefined and understandable instructions to make the request to a database.
>> Select queries request data from a database,
whereas action queries manipulate data in a database.
>> Assembly languages are closely tied to the processor architecture from hardware manufacturers.
Assembly languages are translated using an assembler instead of a complier or interpreter.
And assembly language instructions have a one-to-one association with their machine code counterpart.

 
>> Organizing code before programming has a positive impact on the quality of the program and helps provide a consistent and logical format to use while coding.
>> There are 2 main methods of organizing code : Flowcharts and Pseudocode.

Flowcharts	Pseudocode
Flowchart is a pictorial representation of an algorithm showing the steps as boxes of various	Pseudocode provides a beneficial bridge to the project code because it closely follows the logic that the code will.
Of various shapes and colors connected by arrows that indicate their order.
Flowcharts are used in designing or documenting a process of program.	Pseudocode also helps programmers share ideas without spending too much time creating code, and it provides a structure that is not dependent on any one programming language.
Flowcharts are especially beneficial for smaller concepts and problems	Pseudocode is more efficient for larger programming projects
Flowcharts provide an easy method of communication about the logic and offer a good starting point for the project because they are easier to create than pseudocode in the beginning stages.	
The main purpose of using a flowchart is to analyze different methods of solving a problem or completing a process.	
Some traditional flowchart shapes used for programming concepts are :	
Start/end ( a capsule )
Process ( a rectangle )
Decision ( a diamond )
Data ( a parallelogram )
And connectors ( as arrows )

Some flow chart softwares are Microsoft visio, Lucidchart, Draw.io and Draw Anywhere.	


>> Pseudocode is an informal type of programming description that does not require any strict programming language syntax or underlying technology considerations.
>> System Designers write pseudo code to ensure that programmers understand a software project's requirements and align code accordingly.
>> Pseudocode is used for creating an outline or a rough draft of a program that summarizes a program's flow but excludes underlying details.
>> Pseudocode acts as the bridge between the programmer's brain and the computer's code executor that provides the ability to plan instructions that follow a logical pattern, without including all the technical details.
>> Pseudocode is a great way of getting started with software programming as a beginner without worrying about coding syntax.
>> Pseudocodes helps both programmer's and non-programmers agree about the program's goal and the basics of how the tasks should be done.
Advantages of pseudocode :

>> It's simple and explains exactly what each line of an application should do.
>> The coder can focus more on logic than on program language syntax.
>> Removing the distractions of coding when using pseudocode makes the code development stage easier.
>> Pseudocodes allows programmers working in different computer languages to interact with each other.
>> Pseudocodes can be reviewed by different development groups easier than real code.
>> Pseudocode is easier for non-programmers to read and enables a quick and easy translation to any computer language.
>> writing pseudocode is more concise and easier to modify, so changes to the design can be easily incorporated.
>> Unlike some flowcharts, pseudocode is usually less than one page.

![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/3f271501-8e25-4ee8-a4e7-63aa79531bea)
![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/a46a9ac0-e6ea-400d-8ed9-eb4e2294f637)
![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/c21ca4e4-7df6-4637-ba96-11b57fa38091)
![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/b8e50139-830f-4dfc-b119-09626d008813)

 









>> Branching is deciding what actions to take and looping is deciding how many times  to perform an action.

Programming concepts :
Identifiers :
>> software developers use an identifier to reference a program component such as a stored value, a method , an interface, or a class, by assigning a custom named label to it.
>> If the identifier stores data, then the data values in the program can be one of two types :
Either a constant , or a variable.
>> A constant is a data item whose value does not change within a program.
This could be a numerical constant such as the mathematical value of Pi,
or it could be a text string that remains constant such as a player’s name within a game.
Pros of constants :
>> Ease of readability in your code
>> if the specified value changes in the future, you only need to change it once on the constant, rather than finding every instance of that numerical value within your code and changing it.

>> Variable is not constant. It's value can be changed during program's execution.
Ex : user entering their age in an application or high score in a game.
>> variable can be strings of text, numerical values or any other type of data.

There are 2 types of containers to specify multiple elements: arrays and vectors.
>> The simplest of these container type is an array.
>> In an array, a fixed number of elements of the same type are stored in sequential order, starting from index zero.
>> When you declare an array, you specify the data type of the values it contains, such as integer, or boolean or a string and then the maximum number of elements it can contain.
>> The syntax for declaring an array is to specify the data type first, then the name of the array, then the maximum size of the array in square braces.


>> vectors have a dynamic size, and they will automatically resize themselves as you add elements to them or remove elements from them.
>> For these reason, they are also called as dynamic arrays.
Vectors can take up more memory space than arrays.
>> Elements in vectors take a little longer to access than elements in array


![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/33bfbefb-b627-4765-800f-24342491b63d)
![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/7acd2b82-e620-4eb6-8117-a32a756aa0fa)




 

Programming concepts :


![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/982fc623-181c-465e-8a80-5f100a14ef6d)
![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/96fb5076-e67a-4713-a10c-3786ae786710)
![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/225abe3a-deaa-4f0a-875e-a7e8016134a7)
![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/85655f0e-75d8-4f69-ad09-1a50c2ba19e8)
![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/c9644e80-64f4-41c7-b976-785a6142e302)
![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/74820c50-a3a5-4cac-bc94-620dea4690e3)









Software Architecture, Design and patterns
>>  software design and documentation take place during the design phase of the SDLC.
>>  software architecture serves as a blueprint for the software system that the programmers use to develop the interacting components of the software.
>> The architecture comprises the fundamental structures of a software system and explains the behavior of that system.
>>  The architecture defines how components should interact with each other, the operating environment, and the principles used to design the software.
>> The software architecture captures early design decisions that are often costly to change once implemented.
>> A software's architecture addresses non-functional aspects of the application such as performance, scalability, maintainability, interoperability, security and manageability.

Reasons for well-designed software architecture :
--> It balances the differing needs of the stakeholders and serves as a basis for communication among team members.
--> The architecture represents the earliest design decisions, and those decisions conflate other coding implementation decisions later in the development process.
--> A well designed architecture allows for agility due to changing requirements.
--> A well-designed architecture increases the lifespan of the software system even when implementation details change.
--> Architectural design also guides the choice of technology stacks used for the system.
--> Several artifacts produced during the architectural design phase that are used to communicate the software design to the stakeholders. These artifacts include design document, of SDD, an architectural diagram, and unified modeling language, or UML diagrams.

--> SDD is a collection of technical specifications that indicate how the design should be implemented.
   It Provides a functional description of the software and design considerations such as assumptions, dependencies, constraints, requirements, objectives, and methodologies.

The architectural diagrams displays components, their interactions, their constraints and their confines.
>> Architectural patterns are general, reusable solutions to commonly occurring problem

 
>> UML diagrams are diagrams that communicate structure and behavior using common programming language agnostic notation.
>> The application to the end-user such as the servers, load balancers, and databases.

Software Design and Modeling

>> Software Design is a process during which structural components and behavioral attributes of the software are documented before it can be developed.
>> One of the key activities of the design process is modeling the software to express its design.

>> A software system can be constructed in terms of structural elements. Structured design conceptualizes a software problem into well-organized smaller solution elements called modules and sub-modules.
>> A structural design stresses organization in order to achieve a solution. A well-structured design should contain modules that are cohesive and loosely coupled.

Cohesion means that all functionality related elements are grouped together.
Coupling is the communication between different modules. For a system to be loosely coupled the modules should be weakly associated so changes in one component have minimal effect on another.


Ø Behavioral models describe what a system does, without explaining how does it.
Ø The overall behavior of a system can be communicated through behavioral models.

There are number of different UML diagrams that can be used to communicate the behavior of a system. We will discuss two of such diagrams,
A state transition diagram and an interaction diagram.

>> UML , which stands for Unified Modeling Language, is a way to visually represent the architecture, design, and implementation of complex software systems. UML is a standardized modeling language that can be used throughout development processes.

>> UML Diagrams can be divided into two classes. Either structural or behavioral
>> UML is a programming language agnostic, so software developers can readily interpret and apply it to their work no matter which language they are developing in .

Advantages of UML diagrams :
----------------------------------------
>> Plan out features before any coding takes place which saves time and money.
>> The diagrams can be used to bring new team members or developers switching teams to get up to speed quickly.
>> These diagrams used to facilitate communication between technical and non-technical audience more easily.
>> Having visual representation of the system allows developers to navigate the source code because they can see the relationships among modules.

>> The behavior of a system can be explained and represented with the help of a UML diagram called a state transition diagram.
>>  The state transition diagram is a collection of states and events that describes the different states that a system has and the events which cause a change of state in the system
>> An interaction diagram is used to model the dynamic nature of a software system. They
help visualize objects and their relationships. A sequence diagram, which is the type of interaction
diagram shown here, displays the communication between objects with respect to time.

Object oriented Analysis and Design :
-----------------------------------------------------
>> Object-oriented analysis and design is the process of planning a software system based on the behaviors of interacting objects

>> Object Oriented Analysis and Design or OOAD for short, is an approach for analyzing and designing a software system when the system will use object oriented programming languages to develop it
>> Objects contains data, and they also have behaviors that prescribe the actions the object can take.
>> The genic version of an object is called a "class"
>> specific objects, also called instances are created from "classes" which are blueprints or templates for an object.
>> The class contains the object's generic attributes -- the properties and methods-but it is only when the object is created, which is called "instantiation" inside the code that these generic attributes are set to particular values.


>> OOAD is used for a system that can be broken down into objects that interact with each other.

>> Class diagrams are commonly used to communicate a software system’s structure in OOAD.


![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/5ddf2142-b13c-4a1a-bdbd-4fc91ea76265)

 


>> The class diagram show how the classes in an object-oriented design relate to one another.
>> An object's attributes are both its properties or its data, and its available actions, called methods.
>> A class diagram also shows the relationships between classes.
>> A subclass is said to "inherit" its parent class attributes meaning it has the  same properties and methods as the parent class but also may add additional properties and methods.

Different Architecture Patterns
1. Peer to peer
	>> peer-to-peer architectures consist of a decentralized network of nodes that behave both as client and as server.
	![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/74057b07-1bab-49eb-ac84-c300493347bb)

2. Microservices
	>> Microservice Architectures have applications composed of several loosely coupled services that communicate using API.
	![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/dc707676-558d-4ed0-b3db-c03bfcc8e471)

3. Event-Driven
	>> Events-driven architectures have consumers that send requests to producers.
	![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/e9eea02e-c99f-400e-bd01-b06d61cae3c5)

4. Two-Tier
	>> Two tier architectures have clients that communicates with server.
	![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/0f91a8f6-462a-4455-ba4b-c630f09b7a57)

5. Three-Tier
	>> Three-tier architectures consist of three-tiers: presentation, application and data.
	![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/078b16f8-c3e1-4e35-8210-ec0f6695a547)

 

Approaches to Application Architecture
------------------------------------------------------
A component is an individual unit of encapsulated functionality that serves as a part of an application in conjuction with other components.
There are six characteristics of components. Components should be
Reusable
	>> It means components should be designed such that they can be reused in different applications.
Replaceable
	>> It means components should be easily replaced with another component.
Independent
	>> It means component should be designed so it doesn't have dependencies on other components.
Extensible
	>> It means ability to add behavior to a component without changing other components.
Encapsulated
	>> It consists of bundling a component's data and methods to hide its internal state, so it doesn't expose its specific implementation.
Non-context specific
	>> It means involving of designing so it operates in different environments. Data that sets its internal state should be passed to the component rather than included within or accessed by component.

A controller is a type of component that determines which other components need to be called for a particular event. It controls the flow of data between two other components.
A component-based architecture provides a higher level of abstraction than object oriented designs.

A service is like a component, also a unit of functionality, but it is designed to be deployed indeendently and reused by multiple systems.
A service focuses on a solution to a business need.
A key difference between a component and a service is that a service will only have one unique, always running instance with whom multiple clients communicate .

Services are made up of components and components consists of objects.
A service is a type of component. It is meant to be deployed independently of the overall system.


A distributes system is a system with multiple services located on different machines that coordinate interactions by passing messages to each other via a communication protocol such as Hypertext transfer protocol such as HTTP. 
>> A distributes system shares resources such as hardware, software and data.
>> They are fault-tolerant, meaning if a node or a service is fails the system continues to run also implying that the system may change during execution without service interupption.
>> Multiple activities run concurrently on a distributed system reducing latency and increasing throughput.
>> Distributed systems are scalable as the number of users increases.
>> The computers running distributed systems do not need to use the same kind of hardware or operating systems.
>> A distributed system consists of multiple interconnected nodes where the nodes are running one or more services in an SOA.
>> A distributed systems generally use one or more of the following basic types of archtiecture :
Client-server
Three-tier
Peer-to-peer or microservices.

![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/e7bab233-ddb9-45c5-bfeb-4372fb45f269)

Application Deployment Environments
>> An application Environment is the combination of the hardware and software resources required to run an application.
Pre-prod Environment are those platforms that are application resides on in various forms as it gets prepared for production. 
Common pre-production environments are "development", "QA" and "staging".
>> The development environment is the platform on which the application is being actively coded , and in many cases it may just be the developer's workstation.
>> The QA environment , sometimes called "testing" is the environment that allow the QA team to test the application's components.
>> The staging environment is the environment that is as close to replicating the production environment as possible but is not meant for general users. 
>> The production environment often just called "production" includes the entire solution stack consisting of both hardware and software on which the application runs as additional infrastructure components.
>> The production environment is intended for all users.
>> Production environment must also take into account non-functional requirements like security, reliability, and scalability.
Production deployments 
![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/c77a97fd-9cd8-44fd-b1a6-bed1c350622f)

A firewall is a security device that monitors traffic between networks.
It permits or blocks requested data based on a set of security rules.
>> It acts as a barrier between networks to blocks viruses, malware, and hackers from accessing the internal network.
>> the purpose of load balancer is to distribute network traffic efficiently amongst multiple servers called server farm, on a network.

>> Loadbalancers are used to prevent server traffic overload and are located between clients and the servers.
>> A load balancer determines which servers are capable of fulfilling those requirements in a manner that maximizes availability and responsiveness.
>> Loadbalancers ensure that no one server is overworked. They manage concurrent requests from clients and return the correct data in a fast and reliable manner.
>> Web and application servers are either software or machine that provides services, resources, data or applications to another computer program called the client.

Servers store, process and manage network data, devices and systems.
>> A web server delivers content such as web pages, files, images and videos to a client.
>> An app server is a server that runs business logic and provides the application to the client rather than the client running app on their own machine.
It's primary job is to enable interaction between the end-user and the server-side application code.

A proxy server is an intermediate server that sits in between two tiers and handles requests between those tiers.
A proxy server can serve multiple purposes such as loadbalancing, system optimization, caching, acting as a firewall, obscuring the source of the request, encryption, scanning  for malware and more.

A database is a collection of related data, stored on a computer that can be accessed in various ways.
A database is usually controlled by software called a database management system or DBMS.
The database server controls the flow and storage of data. 
The DBMS connects the database server to an application so data stored in the database can be retrieved or manipulated by the application





Final Project 

Final Project Overview

Overview
There are a total of 20 points for 14 tasks in this optional final project. Your final assignment will be graded by your peers who are also completing this assignment within the same session. You need to complete the following and submit your responses for peer reviews. 
For this guided final project, find a software engineering job posting that interests you on a job board of your choice such as LinkedIn, Indeed, or Zip Recruiter. Find a post that piques your curiosity and that you can see yourself applying to in the future when you have the right combination of skills. 
Analyze the posting by responding to the following questions and statements. Enter your responses in the text boxes provided and submit screenshots when requested.
To take a screenshot in Windows, use the snipping tool by going to the start menu and opening the snipping tool. Click “New” then click and drag over the area of the screen you want to screenshot. Save the file as a .png file or a .jpg file.
To take a screenshot on MacOSX press shift+command+4 then click and drag over the area of the screen you want to screenshot. The file will be saved to your desktop. 
To upload the file, click the upload file button, click browse, and navigate to the file, or drag and drop the file icon onto the window. 
7. Upload a screenshot that displays the company name, the job title, the expected salary range, and job location as a .png file or a .jpg file (see instructions above on how to take a screenshot.)
8. What is the company name that is advertising the job? 
9. What is the job title of the role? 
10. What is the expected salary range for the role? 
11. Where is the role located? 
12. What is the URL of the job post? 
13. What search term(s) did you use to find the job post? 
14. How many total results were returned for that search? 
15. List 2 required skills for this job. 
16. Describe the expected education and experience required to apply for this job. 
17. Provide a reason as to why this particular job is of interest to you and provide details from the post that highlight your interest. 
18. List two hard skills required for the job that you don’t already have or would like to improve on. 
19. Name two soft skills that would be helpful to have if you were hired for this role. 
20. State at least two ideas or concepts you learned about in this course that are relevant to this job post. 
Grading Criteria Overview
There are a total of 20 points possible for the final project.
Your grade will be based on the following tasks: 
• Task 1 – Scroll to the bottom of your screen and use the File Uploads option to upload a screenshot that displays the company name, the job title, the expected salary range, and job location. After adding the file, type “See File Upload” in the text box below. (1 pt)
![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/c2515f0d-035d-40ad-8b2d-db241a965b7a)

• Tasks 2-5 – Provide the company name, job title, expected salary range, and location of the job post. (4 pts) 
• Task 6 – Provide the URL of the job post. (1 pt) 
• Task 7 – Provide the search term(s) you used to find this job post. (1 pt) 
• Task 8–Provide the total number of search results from your search. (1 pt) 
• Task 9–List 2 required skills for this job. (2 pts) 
• Task 10–Provide expected education and experience. (2 pts) 

• Task 11–Provide a reason as to why this particular job is of interest to you and provide details from the post that highlight your interest. (2 pts) 
• Task 12–Provide two hard skills you need that you don’t already have or ones that you would like to improve on in order to apply for this job. (2 pts) 
• Task 13 – If you wanted to apply for this job, name two soft skills that would be helpful to have if you were to be hired for this role. (2 pts) 
• Task 14–State at least two concepts that were taught in this course that are relevant to this job post. (2 pts) 
Example Submissions
Here is an example of a submission that provides example responses for all tasks.
Task 1: Scroll to the bottom of your screen and use the File Uploads option to upload a screenshot that displays the company name, the job title, the expected salary range, and job location. After adding the file, type “See File Upload” in the text box below.


![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/ee566c89-f4e0-42eb-8d3d-60aa83cef592)

Task 2: What is the company name that is advertising the job? Tersa Employment Agency
Task 3: What is the job title of the role? Software Engineer – Python/AngularJS
Task 4: What is the expected salary range for the role? $76,000-$96,000
Task 5: Where is the role located? Remote
Task 6: What is the URL of the job post? https://www.indeed.com/jobs?q=software+engineer&l=remote&from=searchOnHP&vjk=6119f85ad67341c0
Task 7: What search term(s) did you use to find the job post? Software engineer
Task 8: How many total results were returned for that search? 70,382
Task 9: List 2 required skills for this job:
21. Knowledge of basic concepts of Python / Django  
22. Knowledge of basic concepts of AngularJS 
Task 10: Describe the expected education and experience required to apply for this job:
Education: Bachelor’s Degree in Computer Science or related field or equivalent level of experience required.
Experience: 
• 1-3 years of experience using Python/Django. 
• Advanced skills with Angular JS. 
• Previous experience with SQL, XML, JSON, JavaScript. 
• Experience with ASP.NET/C# is preferred. 
• Experience with AWS S3 services is preferred. 
• Experience with Git. 
• Experience working with Web services, Web API, MVC, Bootstrap, jQuery, Microservices, Multi-Threaded and Concurrent systems. 
• Working knowledge of Agile Software Development and developer role on an Agile Team. 
• Experience with SaaS and software architectural models (SOA, EDA, etc.) are required. 
Task 11: Provide a reason as to why this particular job is of interest to you and provide details from the post that highlight your interest:
The benefits look terrific.
• 401(k) 
• 401(k) matching 
• Dental insurance 
• Employee assistance program 
• Employee discount 
• Flexible schedule 
• Flexible spending account 
• Health insurance 
• Health savings account 
• Life insurance 
• Paid time off 
• Parental leave 
• Referral program 
• Relocation assistance 
• Retirement plan 
• Tuition reimbursement 
• Vision insurance 
Task 12: List two hard skills required for the job that you don’t already have or would like to improve on:
23. Knowledge of basic concepts of Python/Django 
24. Knowledge of basic concepts of Angular JS 
Task 13: Name two soft skills that would be helpful to have if you were hired for this role:
25. Strong communication skills  
26. Strong self-discipline 
Task 14: State at least two ideas or concepts you learned about in this course that are relevant to this job post:
27. Working with a team  
28. Using tools to maintain, debug, and test software 































![image](https://github.com/Charan-happy/MyTechskillimprovement/assets/89054489/8add2f25-57f6-4b43-a0b7-ff075d99ce8c)
